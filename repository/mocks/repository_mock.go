// Code generated by MockGen. DO NOT EDIT.
// Source: repository.go

// Package repositorymock is a generated GoMock package.
package repositorymock

import (
	context "context"
	os "os"
	reflect "reflect"
	time "time"

	model "github.com/aferryc/yars/model"
	postgres "github.com/aferryc/yars/repository/postgres"
	gomock "go.uber.org/mock/gomock"
)

// MockBankStatementRepository is a mock of BankStatementRepository interface.
type MockBankStatementRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBankStatementRepositoryMockRecorder
}

// MockBankStatementRepositoryMockRecorder is the mock recorder for MockBankStatementRepository.
type MockBankStatementRepositoryMockRecorder struct {
	mock *MockBankStatementRepository
}

// NewMockBankStatementRepository creates a new mock instance.
func NewMockBankStatementRepository(ctrl *gomock.Controller) *MockBankStatementRepository {
	mock := &MockBankStatementRepository{ctrl: ctrl}
	mock.recorder = &MockBankStatementRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBankStatementRepository) EXPECT() *MockBankStatementRepositoryMockRecorder {
	return m.recorder
}

// FetchAll mocks base method.
func (m *MockBankStatementRepository) FetchAll(start, end time.Time) (model.BankStatementList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAll", start, end)
	ret0, _ := ret[0].(model.BankStatementList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAll indicates an expected call of FetchAll.
func (mr *MockBankStatementRepositoryMockRecorder) FetchAll(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAll", reflect.TypeOf((*MockBankStatementRepository)(nil).FetchAll), start, end)
}

// FindByID mocks base method.
func (m *MockBankStatementRepository) FindByID(id int) (model.BankStatement, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", id)
	ret0, _ := ret[0].(model.BankStatement)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockBankStatementRepositoryMockRecorder) FindByID(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockBankStatementRepository)(nil).FindByID), id)
}

// Save mocks base method.
func (m *MockBankStatementRepository) Save(statement model.BankStatement) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", statement)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockBankStatementRepositoryMockRecorder) Save(statement interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockBankStatementRepository)(nil).Save), statement)
}

// MockInternalTransactionRepository is a mock of InternalTransactionRepository interface.
type MockInternalTransactionRepository struct {
	ctrl     *gomock.Controller
	recorder *MockInternalTransactionRepositoryMockRecorder
}

// MockInternalTransactionRepositoryMockRecorder is the mock recorder for MockInternalTransactionRepository.
type MockInternalTransactionRepositoryMockRecorder struct {
	mock *MockInternalTransactionRepository
}

// NewMockInternalTransactionRepository creates a new mock instance.
func NewMockInternalTransactionRepository(ctrl *gomock.Controller) *MockInternalTransactionRepository {
	mock := &MockInternalTransactionRepository{ctrl: ctrl}
	mock.recorder = &MockInternalTransactionRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInternalTransactionRepository) EXPECT() *MockInternalTransactionRepositoryMockRecorder {
	return m.recorder
}

// FetchAll mocks base method.
func (m *MockInternalTransactionRepository) FetchAll(start, end time.Time) (model.TransactionList, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchAll", start, end)
	ret0, _ := ret[0].(model.TransactionList)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FetchAll indicates an expected call of FetchAll.
func (mr *MockInternalTransactionRepositoryMockRecorder) FetchAll(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchAll", reflect.TypeOf((*MockInternalTransactionRepository)(nil).FetchAll), start, end)
}

// FindByID mocks base method.
func (m *MockInternalTransactionRepository) FindByID(id string) (model.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", id)
	ret0, _ := ret[0].(model.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockInternalTransactionRepositoryMockRecorder) FindByID(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockInternalTransactionRepository)(nil).FindByID), id)
}

// Save mocks base method.
func (m *MockInternalTransactionRepository) Save(transaction model.Transaction) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", transaction)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockInternalTransactionRepositoryMockRecorder) Save(transaction interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockInternalTransactionRepository)(nil).Save), transaction)
}

// MockGCSRepository is a mock of GCSRepository interface.
type MockGCSRepository struct {
	ctrl     *gomock.Controller
	recorder *MockGCSRepositoryMockRecorder
}

// MockGCSRepositoryMockRecorder is the mock recorder for MockGCSRepository.
type MockGCSRepositoryMockRecorder struct {
	mock *MockGCSRepository
}

// NewMockGCSRepository creates a new mock instance.
func NewMockGCSRepository(ctrl *gomock.Controller) *MockGCSRepository {
	mock := &MockGCSRepository{ctrl: ctrl}
	mock.recorder = &MockGCSRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGCSRepository) EXPECT() *MockGCSRepositoryMockRecorder {
	return m.recorder
}

// DownloadFromBucket mocks base method.
func (m *MockGCSRepository) DownloadFromBucket(ctx context.Context, objectName string) (*os.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DownloadFromBucket", ctx, objectName)
	ret0, _ := ret[0].(*os.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DownloadFromBucket indicates an expected call of DownloadFromBucket.
func (mr *MockGCSRepositoryMockRecorder) DownloadFromBucket(ctx, objectName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadFromBucket", reflect.TypeOf((*MockGCSRepository)(nil).DownloadFromBucket), ctx, objectName)
}

// GenerateDownloadURL mocks base method.
func (m *MockGCSRepository) GenerateDownloadURL(objectName string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateDownloadURL", objectName)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateDownloadURL indicates an expected call of GenerateDownloadURL.
func (mr *MockGCSRepositoryMockRecorder) GenerateDownloadURL(objectName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateDownloadURL", reflect.TypeOf((*MockGCSRepository)(nil).GenerateDownloadURL), objectName)
}

// GenerateUploadURL mocks base method.
func (m *MockGCSRepository) GenerateUploadURL(objectName, contentType string, expires time.Time) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateUploadURL", objectName, contentType, expires)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateUploadURL indicates an expected call of GenerateUploadURL.
func (mr *MockGCSRepositoryMockRecorder) GenerateUploadURL(objectName, contentType, expires interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateUploadURL", reflect.TypeOf((*MockGCSRepository)(nil).GenerateUploadURL), objectName, contentType, expires)
}

// MockKafkaRepository is a mock of KafkaRepository interface.
type MockKafkaRepository struct {
	ctrl     *gomock.Controller
	recorder *MockKafkaRepositoryMockRecorder
}

// MockKafkaRepositoryMockRecorder is the mock recorder for MockKafkaRepository.
type MockKafkaRepositoryMockRecorder struct {
	mock *MockKafkaRepository
}

// NewMockKafkaRepository creates a new mock instance.
func NewMockKafkaRepository(ctrl *gomock.Controller) *MockKafkaRepository {
	mock := &MockKafkaRepository{ctrl: ctrl}
	mock.recorder = &MockKafkaRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKafkaRepository) EXPECT() *MockKafkaRepositoryMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockKafkaRepository) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockKafkaRepositoryMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockKafkaRepository)(nil).Close))
}

// Publish mocks base method.
func (m *MockKafkaRepository) Publish(ctx context.Context, topic, key string, message any) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, topic, key, message)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockKafkaRepositoryMockRecorder) Publish(ctx, topic, key, message interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockKafkaRepository)(nil).Publish), ctx, topic, key, message)
}

// MockReconResultRepository is a mock of ReconResultRepository interface.
type MockReconResultRepository struct {
	ctrl     *gomock.Controller
	recorder *MockReconResultRepositoryMockRecorder
}

// MockReconResultRepositoryMockRecorder is the mock recorder for MockReconResultRepository.
type MockReconResultRepositoryMockRecorder struct {
	mock *MockReconResultRepository
}

// NewMockReconResultRepository creates a new mock instance.
func NewMockReconResultRepository(ctrl *gomock.Controller) *MockReconResultRepository {
	mock := &MockReconResultRepository{ctrl: ctrl}
	mock.recorder = &MockReconResultRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReconResultRepository) EXPECT() *MockReconResultRepositoryMockRecorder {
	return m.recorder
}

// GetUnmatchedBankStatements mocks base method.
func (m *MockReconResultRepository) GetUnmatchedBankStatements(ctx context.Context, taskID string, limit, offset int) ([]postgres.UnmatchedBankStatement, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnmatchedBankStatements", ctx, taskID, limit, offset)
	ret0, _ := ret[0].([]postgres.UnmatchedBankStatement)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUnmatchedBankStatements indicates an expected call of GetUnmatchedBankStatements.
func (mr *MockReconResultRepositoryMockRecorder) GetUnmatchedBankStatements(ctx, taskID, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnmatchedBankStatements", reflect.TypeOf((*MockReconResultRepository)(nil).GetUnmatchedBankStatements), ctx, taskID, limit, offset)
}

// GetUnmatchedTransactions mocks base method.
func (m *MockReconResultRepository) GetUnmatchedTransactions(ctx context.Context, taskID string, limit, offset int) ([]postgres.UnmatchedTransaction, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnmatchedTransactions", ctx, taskID, limit, offset)
	ret0, _ := ret[0].([]postgres.UnmatchedTransaction)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetUnmatchedTransactions indicates an expected call of GetUnmatchedTransactions.
func (mr *MockReconResultRepositoryMockRecorder) GetUnmatchedTransactions(ctx, taskID, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnmatchedTransactions", reflect.TypeOf((*MockReconResultRepository)(nil).GetUnmatchedTransactions), ctx, taskID, limit, offset)
}

// ListSummaries mocks base method.
func (m *MockReconResultRepository) ListSummaries(ctx context.Context, limit, offset int) ([]postgres.ReconSummary, int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListSummaries", ctx, limit, offset)
	ret0, _ := ret[0].([]postgres.ReconSummary)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListSummaries indicates an expected call of ListSummaries.
func (mr *MockReconResultRepositoryMockRecorder) ListSummaries(ctx, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSummaries", reflect.TypeOf((*MockReconResultRepository)(nil).ListSummaries), ctx, limit, offset)
}

// StoreSummary mocks base method.
func (m *MockReconResultRepository) StoreSummary(ctx context.Context, summary model.ReconciliationSummary, startDate, endDate time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StoreSummary", ctx, summary, startDate, endDate)
	ret0, _ := ret[0].(error)
	return ret0
}

// StoreSummary indicates an expected call of StoreSummary.
func (mr *MockReconResultRepositoryMockRecorder) StoreSummary(ctx, summary, startDate, endDate interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoreSummary", reflect.TypeOf((*MockReconResultRepository)(nil).StoreSummary), ctx, summary, startDate, endDate)
}
